<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hash encode / decode</title>
  <style>
    * { box-sizing: border-box; }
    body, input, textarea, select { font-family: system-ui, sans-serif; -webkit-user-select: text; user-select: text; }
    body { margin: 0; padding: 1rem; background: #f0f1f3; color: #1a1a1a; font-size: 0.95rem; }
    h1 { font-size: 1.25rem; margin: 0 0 0.5rem 0; }
    .note { font-size: 0.85rem; color: #555; margin: 0 0 1rem 0; }
    .card { background: #fff; border-radius: 10px; padding: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,0.08); border: 1px solid #e5e7eb; margin-bottom: 1rem; }
    .card h2 { font-size: 0.95rem; margin: 0 0 0.5rem 0; color: #333; }
    label { display: block; margin-bottom: 0.25rem; font-weight: 500; font-size: 0.9rem; }
    .row { margin-bottom: 0.75rem; }
    textarea { width: 100%; min-height: 80px; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px; font-family: ui-monospace, monospace; font-size: 0.9rem; resize: vertical; }
    textarea:focus { outline: none; border-color: #1a73e8; }
    input[type="text"], input[type="password"], select { padding: 0.4rem 0.5rem; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9rem; }
    input:focus, select:focus { outline: none; border-color: #1a73e8; }
    .opts { display: flex; flex-wrap: wrap; align-items: center; gap: 0.75rem; margin-bottom: 0.5rem; }
    .opts label { margin-bottom: 0; margin-right: 0.25rem; font-weight: normal; }
    #algo { min-width: 18rem; max-width: 100%; }
    .algo-first { margin-top: 0; }
    .algo-first .algo-heading { font-size: 1rem; margin: 0 0 0.5rem 0; color: #1a1a1a; }
    .key-row { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; margin-top: 0.35rem; }
    .key-select { min-width: 10rem; }
    .key-input { flex: 1; min-width: 12rem; max-width: 24rem; }
    button { padding: 0.45rem 0.75rem; font: inherit; cursor: pointer; border: 1px solid #ccc; border-radius: 4px; background: #f5f5f5; }
    button:hover { background: #e8e8e8; }
    button.primary { background: #1a73e8; color: #fff; border-color: #1a73e8; }
    button.primary:hover { background: #1557b0; }
    .output-wrap { margin-top: 0.75rem; }
    #output { min-height: 80px; background: #f8f9fa; }
    .error { color: #c00; font-size: 0.9rem; margin-top: 0.35rem; }
    .local-banner { background: #e8f5e9; border: 1px solid #a5d6a7; border-radius: 6px; padding: 0.5rem 0.75rem; margin-bottom: 1rem; font-size: 0.85rem; color: #2e7d32; }
    .about-section { margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid #e5e7eb; }
    .about-section h2 { font-size: 1rem; margin: 0 0 0.75rem 0; color: #333; }
    .algo-desc { background: #fff; border-radius: 8px; padding: 0.75rem 1rem; margin-bottom: 0.6rem; border: 1px solid #e5e7eb; font-size: 0.88rem; line-height: 1.5; }
    .algo-desc strong { color: #1a1a1a; }
    .algo-desc code { font-family: ui-monospace, monospace; font-size: 0.85em; background: #f0f1f3; padding: 0.1rem 0.35rem; border-radius: 3px; }
    .algo-desc p { margin: 0 0 0.35rem 0; }
    .algo-desc p:last-child { margin-bottom: 0; }
    .use-cases { margin-top: 1.25rem; }
    .use-cases ul { margin: 0; padding-left: 1.25rem; font-size: 0.9rem; line-height: 1.6; color: #444; }
    .use-cases li { margin-bottom: 0.4rem; }
  </style>
  <script src="/lib/hash-wasm.umd.min.js"></script>
</head>
<body>
  <div class="card algo-first" id="algoCard">
    <h2 class="algo-heading">Select algorithm (for encode / decode)</h2>
    <div class="opts">
      <label for="algo">Hash or algorithm</label>
      <select id="algo" aria-label="Select hash or algorithm to encode with">
        <optgroup label="Hash — one-way, no key">
          <option value="MD5" selected>MD5 (one-way, no key)</option>
          <option value="SHA-1">SHA-1 (one-way, no key)</option>
          <option value="SHA-224">SHA-224 (one-way, no key)</option>
          <option value="SHA-256">SHA-256 (one-way, no key)</option>
          <option value="SHA-384">SHA-384 (one-way, no key)</option>
          <option value="SHA-512">SHA-512 (one-way, no key)</option>
        </optgroup>
        <optgroup label="HMAC — one-way, key">
          <option value="HMAC-SHA-1">HMAC-SHA-1 (one-way, key)</option>
          <option value="HMAC-SHA-224">HMAC-SHA-224 (one-way, key)</option>
          <option value="HMAC-SHA-256">HMAC-SHA-256 (one-way, key)</option>
          <option value="HMAC-SHA-384">HMAC-SHA-384 (one-way, key)</option>
          <option value="HMAC-SHA-512">HMAC-SHA-512 (one-way, key)</option>
        </optgroup>
        <optgroup label="Symmetric — reversible, key">
          <option value="AES-128-GCM">AES-128-GCM (reversible, key)</option>
          <option value="AES-256-GCM">AES-256-GCM (reversible, key)</option>
        </optgroup>
        <optgroup label="Password hashing — one-way">
          <option value="bcrypt">bcrypt (one-way)</option>
          <option value="scrypt">scrypt (one-way)</option>
          <option value="Argon2id">Argon2id (one-way)</option>
        </optgroup>
      </select>
    </div>
    <p id="detectMsg" class="note" style="margin: 0.35rem 0 0 0;"></p>
  </div>

  <h1>Hash encode / decode</h1>
  <p class="note">Compute hashes (MD5, SHA-*), HMAC with a key, or encrypt/decrypt with AES-256. Use a key from the <strong>Keys</strong> manager (header) or enter your own. Everything runs in your browser.</p>

  <div class="local-banner" role="status">All hashing runs in your browser (including bcrypt, scrypt, Argon2 via WebAssembly). The text you enter is never sent to any server.</div>

  <div class="card" id="keyCard">
    <h2>Key (for HMAC / Encrypt / Decrypt)</h2>
    <div class="key-row">
      <label for="keySelect" class="key-option-label">From key manager</label>
      <select id="keySelect" class="key-select" aria-label="Load key from manager">
        <option value="">— None —</option>
      </select>
      <button type="button" id="btnLoadKey">Use this key</button>
    </div>
    <div class="key-row" style="margin-top: 0.35rem;">
      <label for="keyInput">Or enter key (raw)</label>
      <input type="password" id="keyInput" class="key-input" placeholder="Key for HMAC or AES" autocomplete="off" />
      <label><input type="checkbox" id="showKey" aria-label="Show key" /> Show</label>
    </div>
    <div class="key-row" style="margin-top: 0.5rem;">
      <label for="saveKeyName" class="key-option-label">Save as name</label>
      <input type="text" id="saveKeyName" placeholder="e.g. hmac-key, aes-secret" style="width: 10rem; padding: 0.35rem 0.5rem; border: 1px solid #ccc; border-radius: 4px;" />
      <button type="button" id="btnSaveKey">Remember key</button>
    </div>
    <p class="note" style="margin: 0.5rem 0 0 0;">Keys are stored in the global <strong>Keys</strong> manager (header). Load one above or type a key. For AES-128-GCM the key is hashed to 128 bits; for AES-256-GCM to 256 bits.</p>
  </div>

  <div class="card">
    <h2>Input</h2>
    <div class="row">
      <label for="input">Text to hash / HMAC / encrypt, or ciphertext to decrypt (hex)</label>
      <textarea id="input" placeholder="Paste or type…" rows="4"></textarea>
    </div>
    <div class="row" id="buttonRow">
      <button type="button" id="btnDetect">Detect hash</button>
      <button type="button" id="btnEncode" class="primary">Encode</button>
      <button type="button" id="btnDecode" style="display: none;">Decode</button>
    </div>
    <p id="runError" class="error" style="display: none;"></p>
    <div class="output-wrap">
      <label for="output">Output</label>
      <textarea id="output" readonly placeholder="Result…" rows="4"></textarea>
    </div>
  </div>

  <section class="about-section" aria-labelledby="about-algos">
    <h2 id="about-algos">About the algorithms</h2>

    <div class="algo-desc">
      <strong>MD5</strong> (Message-Digest 5, 1992). Produces a 128-bit (32 hex) hash. Fast and widely used for checksums and non-security uses (e.g. cache keys, ETags). <strong>Not safe for passwords or signatures</strong> — collisions can be found. Still common in legacy systems and file integrity checks where collision resistance is not critical.
    </div>
    <div class="algo-desc">
      <strong>SHA-1</strong> (Secure Hash Algorithm 1, 1995). 160-bit (40 hex) output. Was the standard for TLS and Git commit IDs; now considered weak for new security use. Deprecated for signatures (CAs no longer issue SHA-1 certs). Still used in checksums, some version control, and legacy compatibility.
    </div>
    <div class="algo-desc">
      <strong>SHA-224</strong>. Truncated 224-bit (56 hex) variant of SHA-256. Same security margin as SHA-256 with a shorter output. Used when a smaller hash size is desired (e.g. some protocols or storage constraints) without giving up the SHA-256 family security.
    </div>
    <div class="algo-desc">
      <strong>SHA-256, SHA-384, SHA-512</strong> (SHA-2 family, 2001). 256-, 384- and 512-bit outputs. The standard for security today: TLS, certificates, Bitcoin, password hashing (with salt), integrity checks. SHA-384 and SHA-512 are often used where longer hashes are preferred (e.g. high-security or 64-bit optimized environments).
    </div>
    <div class="algo-desc">
      <strong>HMAC</strong> (Hash-based Message Authentication Code). Same hash algorithms (SHA-1, SHA-224, SHA-256, etc.) but with a <strong>secret key</strong>. Used to prove both integrity and authenticity: only someone with the key can produce a valid HMAC. Typical uses: API request signing, JWT signatures, secure cookies, webhook verification.
    </div>
    <div class="algo-desc">
      <strong>AES-128-GCM, AES-256-GCM</strong>. Symmetric encryption (reversible with the same key). AES in GCM mode provides confidentiality and authenticity. 128-bit key is faster; 256-bit is preferred when you want higher security margin. Key is derived from your password/secret via SHA-256 in this tool (first 16 bytes for AES-128, full 32 for AES-256).
    </div>
    <div class="algo-desc">
      <strong>bcrypt</strong> (1999). Password hashing with a built-in salt and tunable <em>cost</em> (work factor). Output is a single string (e.g. <code>$2b$10$…</code>) that embeds algorithm, cost, salt, and hash — ideal for storing in a database. Resistant to brute-force because each guess is slow; increase cost over time as hardware improves. Widely used in apps and frameworks for password storage.
    </div>
    <div class="algo-desc">
      <strong>scrypt</strong> (2009). Password-based key derivation that is memory-hard: it uses a lot of RAM, making GPU/ASIC attacks costly. Parameters (N, r, p) control cost and memory. Used in many crypto wallets and as a stronger alternative to PBKDF2. Good when you want to slow down attackers with limited memory.
    </div>
    <div class="algo-desc">
      <strong>Argon2</strong> (2015, Password Hashing Competition winner). Modern password hashing with tunable time cost, memory size, and parallelism (Argon2id is the recommended variant). Resistant to side-channel and GPU attacks. Preferred for new applications; use Argon2id when your framework or library supports it.
    </div>

    <div class="use-cases">
      <h2 id="use-cases">Real-world use cases</h2>
      <ul>
        <li><strong>Checksums</strong> — Verify a file or string wasn’t corrupted: hash it and compare to the expected MD5/SHA-256 (e.g. from a download page or manifest).</li>
        <li><strong>Passwords</strong> — Never store plain passwords. Use a dedicated password hasher: <strong>bcrypt</strong>, <strong>scrypt</strong>, or <strong>Argon2</strong> (tunable cost, built-in salt, resistant to brute-force). This tool’s SHA-* hashes are for checksums and integrity, not password storage.</li>
        <li><strong>API / webhook signing</strong> — Sign requests or payloads with HMAC-SHA-256 and a shared secret so the server can verify they came from you (e.g. Stripe, GitHub, Slack webhooks).</li>
        <li><strong>Cache keys</strong> — Turn long strings (URLs, query params) into short fixed-size keys with MD5 or SHA-256 for use in cache or deduplication.</li>
        <li><strong>Encrypted snippets</strong> — Encrypt a config value, token, or message with AES-128-GCM or AES-256-GCM and share the ciphertext (hex); only someone with the key can decrypt it here or in your app.</li>
        <li><strong>Git / version control</strong> — Git uses SHA-1 for commit and object IDs; some tools still show or expect these hashes for lookup or verification.</li>
        <li><strong>Document integrity</strong> — Publish a SHA-256 hash of a document or contract so recipients can confirm it wasn’t altered (e.g. legal or compliance).</li>
        <li><strong>Detect hash type</strong> — Paste an unknown hash and use “Detect hash” to guess MD5 vs SHA-1 vs SHA-256 from its length, then re-encode or verify with the right algorithm.</li>
      </ul>
    </div>
  </section>

  <script>
(function () {
  var ENCRYPTION_KEYS_STORAGE = 'helpers-encryption-keys';
  var TOOL_ORIGIN = 'hash-encode-decode';

  var algo = document.getElementById('algo');
  var detectMsg = document.getElementById('detectMsg');
  var keySelect = document.getElementById('keySelect');
  var keyInput = document.getElementById('keyInput');
  var showKey = document.getElementById('showKey');
  var input = document.getElementById('input');
  var output = document.getElementById('output');
  var btnDetect = document.getElementById('btnDetect');
  var btnEncode = document.getElementById('btnEncode');
  var btnDecode = document.getElementById('btnDecode');
  var runError = document.getElementById('runError');
  var btnLoadKey = document.getElementById('btnLoadKey');
  var saveKeyName = document.getElementById('saveKeyName');
  var btnSaveKey = document.getElementById('btnSaveKey');

  function algoNeedsKey() {
    var a = algo.value;
    return a.indexOf('HMAC-') === 0 || a === 'AES-128-GCM' || a === 'AES-256-GCM';
  }

  function isReversibleAlgo() {
    var a = algo.value;
    return a === 'AES-128-GCM' || a === 'AES-256-GCM';
  }

  function detectHash() {
    var raw = (input.value || '').trim();
    detectMsg.textContent = '';
    if (!raw) {
      detectMsg.textContent = 'Enter or paste input first.';
      return;
    }
    var hexOnly = /^[0-9a-fA-F]+$/.test(raw);
    var len = raw.length;
    if (hexOnly) {
      if (len === 32) { algo.value = 'MD5'; detectMsg.textContent = 'Detected: MD5 (32 hex chars). Use Encode to hash new text.'; updateUI(); return; }
      if (len === 40) { algo.value = 'SHA-1'; detectMsg.textContent = 'Detected: SHA-1 (40 hex chars). Use Encode to hash new text.'; updateUI(); return; }
      if (len === 56) { algo.value = 'SHA-224'; detectMsg.textContent = 'Detected: SHA-224 (56 hex chars). Use Encode to hash new text.'; updateUI(); return; }
      if (len === 64) { algo.value = 'SHA-256'; detectMsg.textContent = 'Detected: SHA-256 (64 hex chars). Use Encode to hash new text.'; updateUI(); return; }
      if (len === 96) { algo.value = 'SHA-384'; detectMsg.textContent = 'Detected: SHA-384 (96 hex chars). Use Encode to hash new text.'; updateUI(); return; }
      if (len === 128) { algo.value = 'SHA-512'; detectMsg.textContent = 'Detected: SHA-512 (128 hex chars). Use Encode to hash new text.'; updateUI(); return; }
    }
    detectMsg.textContent = 'Could not detect hash/format. Choose an algorithm and use Encode or Decode.';
    updateUI();
  }

  function getStoredKeys() {
    try {
      var raw = localStorage.getItem(ENCRYPTION_KEYS_STORAGE);
      if (!raw) return {};
      var parsed = JSON.parse(raw);
      return typeof parsed === 'object' && parsed !== null ? parsed : {};
    } catch (e) { return {}; }
  }

  function keyEntryValue(entry) {
    return typeof entry === 'object' && entry != null && 'value' in entry ? entry.value : entry;
  }

  function setStoredKeyByName(name, value) {
    var obj = getStoredKeys();
    if (value == null || value === '') {
      delete obj[name];
      try { localStorage.setItem(ENCRYPTION_KEYS_STORAGE, JSON.stringify(obj)); } catch (e) {}
      return true;
    }
    if (Object.prototype.hasOwnProperty.call(obj, name)) return false;
    obj[name] = { value: value, origin: TOOL_ORIGIN };
    try { localStorage.setItem(ENCRYPTION_KEYS_STORAGE, JSON.stringify(obj)); } catch (e) {}
    return true;
  }

  function getKeyRaw() {
    var name = (keySelect.value || '').trim();
    if (name) {
      var obj = getStoredKeys();
      var entry = obj[name];
      if (entry != null) return keyEntryValue(entry);
    }
    return (keyInput.value || '').trim();
  }

  function refreshKeyDropdown() {
    var obj = getStoredKeys();
    var names = Object.keys(obj).sort();
    var cur = keySelect.value;
    keySelect.innerHTML = '';
    var opt0 = document.createElement('option');
    opt0.value = '';
    opt0.textContent = '— None —';
    keySelect.appendChild(opt0);
    names.forEach(function (n) {
      var opt = document.createElement('option');
      opt.value = n;
      var origin = typeof obj[n] === 'object' && obj[n] && obj[n].origin ? obj[n].origin : '';
      opt.textContent = origin ? n + ' (' + origin + ')' : n;
      keySelect.appendChild(opt);
    });
    if (names.indexOf(cur) !== -1) keySelect.value = cur;
  }

  function bytesToHex(buf) {
    var a = new Uint8Array(buf);
    var s = '';
    for (var i = 0; i < a.length; i++) s += ('0' + a[i].toString(16)).slice(-2);
    return s;
  }

  function hexToBytes(hex) {
    hex = hex.replace(/\s/g, '');
    if (hex.length % 2) hex = '0' + hex;
    var a = new Uint8Array(hex.length / 2);
    for (var i = 0; i < a.length; i++) a[i] = parseInt(hex.slice(i * 2, i * 2 + 2), 16);
    return a.buffer;
  }

  function strToBytes(str) {
    return new TextEncoder().encode(str).buffer;
  }

  // Minimal MD5 (for browsers that don't have it in crypto)
  function md5Bytes(data) {
    function md5cycle(x, k) {
      var a = x[0], b = x[1], c = x[2], d = x[3];
      a = ff(a, b, c, d, k[0], 7, -680876936);
      d = ff(d, a, b, c, k[1], 12, -389564586);
      c = ff(c, d, a, b, k[2], 17, 606105819);
      b = ff(b, c, d, a, k[3], 22, -1044525330);
      a = ff(a, b, c, d, k[4], 7, -176418897);
      d = ff(d, a, b, c, k[5], 12, 1200080426);
      c = ff(c, d, a, b, k[6], 17, -1473231341);
      b = ff(b, c, d, a, k[7], 22, -45705983);
      a = ff(a, b, c, d, k[8], 7, 1770035416);
      d = ff(d, a, b, c, k[9], 12, -1958414417);
      c = ff(c, d, a, b, k[10], 17, -42063);
      b = ff(b, c, d, a, k[11], 22, -1990404162);
      a = ff(a, b, c, d, k[12], 7, 1804603682);
      d = ff(d, a, b, c, k[13], 12, -40341101);
      c = ff(c, d, a, b, k[14], 17, -1502002290);
      b = ff(b, c, d, a, k[15], 22, 1236535329);
      a = gg(a, b, c, d, k[1], 5, -165796510);
      d = gg(d, a, b, c, k[6], 9, -1069501632);
      c = gg(c, d, a, b, k[11], 14, 643717713);
      b = gg(b, c, d, a, k[0], 20, -373897302);
      a = gg(a, b, c, d, k[5], 5, -701558691);
      d = gg(d, a, b, c, k[10], 9, 38016083);
      c = gg(c, d, a, b, k[15], 14, -660478335);
      b = gg(b, c, d, a, k[4], 20, -405537848);
      a = gg(a, b, c, d, k[9], 5, 568446438);
      d = gg(d, a, b, c, k[14], 9, -1019803690);
      c = gg(c, d, a, b, k[3], 14, -187363961);
      b = gg(b, c, d, a, k[8], 20, 1163531501);
      a = gg(a, b, c, d, k[13], 5, -1444681467);
      d = gg(d, a, b, c, k[2], 9, -51403784);
      c = gg(c, d, a, b, k[7], 14, 1735328473);
      b = gg(b, c, d, a, k[12], 20, -1926607734);
      a = hh(a, b, c, d, k[5], 4, -378558);
      d = hh(d, a, b, c, k[8], 11, -2022574463);
      c = hh(c, d, a, b, k[11], 16, 1839030562);
      b = hh(b, c, d, a, k[14], 23, -35309556);
      a = hh(a, b, c, d, k[1], 4, -1530992060);
      d = hh(d, a, b, c, k[4], 11, 1272893353);
      c = hh(c, d, a, b, k[7], 16, -155497632);
      b = hh(b, c, d, a, k[10], 23, -1094730640);
      a = hh(a, b, c, d, k[13], 4, 681279174);
      d = hh(d, a, b, c, k[0], 11, -358537222);
      c = hh(c, d, a, b, k[3], 16, -722521979);
      b = hh(b, c, d, a, k[6], 23, 76029189);
      a = hh(a, b, c, d, k[9], 4, -640364487);
      d = hh(d, a, b, c, k[12], 11, -421815835);
      c = hh(c, d, a, b, k[15], 16, 530742520);
      b = hh(b, c, d, a, k[2], 23, -995338651);
      a = ii(a, b, c, d, k[0], 6, -198630844);
      d = ii(d, a, b, c, k[7], 10, 1126891415);
      c = ii(c, d, a, b, k[14], 15, -1416354905);
      b = ii(b, c, d, a, k[5], 21, -57434055);
      a = ii(a, b, c, d, k[12], 6, 1700485571);
      d = ii(d, a, b, c, k[3], 10, -1894986606);
      c = ii(c, d, a, b, k[10], 15, -1051523);
      b = ii(b, c, d, a, k[1], 21, -2054922799);
      a = ii(a, b, c, d, k[8], 6, 1873313359);
      d = ii(d, a, b, c, k[15], 10, -30611744);
      c = ii(c, d, a, b, k[6], 15, -1560198380);
      b = ii(b, c, d, a, k[13], 21, 1309151649);
      a = ii(a, b, c, d, k[4], 6, -145523070);
      d = ii(d, a, b, c, k[11], 10, -1120210379);
      c = ii(c, d, a, b, k[2], 15, 718787259);
      b = ii(b, c, d, a, k[9], 21, -343485551);
      x[0] = (a + x[0]) | 0;
      x[1] = (b + x[1]) | 0;
      x[2] = (c + x[2]) | 0;
      x[3] = (d + x[3]) | 0;
    }
    function cmn(q, a, b, x, s, t) {
      a = (a + q + (x || 0) + t) | 0;
      return (((a << s) | (a >>> (32 - s))) + b) | 0;
    }
    function ff(a, b, c, d, x, s, t) { return cmn((b & c) | ((~b) & d), a, b, x, s, t); }
    function gg(a, b, c, d, x, s, t) { return cmn((b & d) | (c & (~d)), a, b, x, s, t); }
    function hh(a, b, c, d, x, s, t) { return cmn(b ^ c ^ d, a, b, x, s, t); }
    function ii(a, b, c, d, x, s, t) { return cmn(c ^ (b | (~d)), a, b, x, s, t); }
    function md5blk(s) {
      var md5blks = [], i;
      for (i = 0; i < 64; i += 4) md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
      return md5blks;
    }
    var n = data.length, state = [1732584193, -271733879, -1732584194, 271733878], i;
    for (i = 64; i <= data.length; i += 64) md5cycle(state, md5blk(data.substring(i - 64, i)));
    data = data.substring(i - 64);
    var tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i < data.length; i++) tail[i >> 2] |= data.charCodeAt(i) << ((i % 4) << 3);
    tail[i >> 2] |= 0x80 << ((i % 4) << 3);
    if (i > 55) { md5cycle(state, tail); for (i = 0; i < 16; i++) tail[i] = 0; }
    tail[14] = n * 8;
    md5cycle(state, tail);
    var out = '';
    for (i = 0; i < 4; i++) out += String.fromCharCode(state[i] & 0xff, (state[i] >>> 8) & 0xff, (state[i] >>> 16) & 0xff, (state[i] >>> 24) & 0xff);
    return out;
  }

  function hashMD5(bytes) {
    var s = '';
    var u8 = new Uint8Array(bytes);
    for (var i = 0; i < u8.length; i++) s += String.fromCharCode(u8[i]);
    return md5Bytes(s);
  }

  function showErr(msg) {
    runError.textContent = msg || '';
    runError.style.display = msg ? 'block' : 'none';
  }

  function setOutput(t) {
    output.value = t || '';
  }

  function updateUI() {
    var needsKey = algoNeedsKey();
    var keyCard = document.getElementById('keyCard');
    if (keyCard) keyCard.style.display = needsKey ? 'block' : 'none';
    if (btnDecode) btnDecode.style.display = isReversibleAlgo() ? 'inline-block' : 'none';
  }

  async function doEncode() {
    var alg = algo.value;
    var raw = (input.value || '').trim();
    showErr('');
    setOutput('');
    if (!raw) { showErr('Enter text to hash / HMAC / encrypt.'); return; }

    var hashAlgos = ['MD5', 'SHA-1', 'SHA-224', 'SHA-256', 'SHA-384', 'SHA-512'];
    if (hashAlgos.indexOf(alg) !== -1) {
      var data = strToBytes(raw);
      var hashBuf;
      if (alg === 'MD5') {
        var md5Str = hashMD5(data);
        hashBuf = new ArrayBuffer(md5Str.length);
        new Uint8Array(hashBuf).set(md5Str.split('').map(function(c) { return c.charCodeAt(0); }));
      } else {
        try {
          hashBuf = await crypto.subtle.digest(alg, data);
        } catch (e) {
          showErr(alg + ' is not supported in this browser. Try SHA-256 or SHA-512.');
          return;
        }
      }
      setOutput(bytesToHex(hashBuf));
      return;
    }

    if (alg.indexOf('HMAC-') === 0) {
      var keyStr = getKeyRaw();
      if (!keyStr) { showErr('Select or enter a key for HMAC.'); return; }
      var hashAlg = alg.replace('HMAC-', '');
      var keyBytes = strToBytes(keyStr);
      var key = await crypto.subtle.importKey('raw', keyBytes, { name: 'HMAC', hash: hashAlg }, false, ['sign']);
      var data = strToBytes(raw);
      var sig = await crypto.subtle.sign('HMAC', key, data);
      setOutput(bytesToHex(sig));
      return;
    }

    if (alg === 'AES-128-GCM' || alg === 'AES-256-GCM') {
      var keyStrEnc = getKeyRaw();
      if (!keyStrEnc) { showErr('Select or enter a key for encryption.'); return; }
      var keyHashFull = new Uint8Array(await crypto.subtle.digest('SHA-256', strToBytes(keyStrEnc)));
      var keyLen = alg === 'AES-128-GCM' ? 128 : 256;
      var keyBytes = keyLen === 128 ? keyHashFull.slice(0, 16) : keyHashFull;
      var keyBuf = keyLen === 128 ? keyBytes.buffer.slice(0, 16) : keyBytes.buffer;
      var key = await crypto.subtle.importKey('raw', keyBuf, { name: 'AES-GCM', length: keyLen }, false, ['encrypt']);
      var iv = crypto.getRandomValues(new Uint8Array(12));
      var enc = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv, tagLength: 128 }, key, strToBytes(raw));
      var combined = new Uint8Array(iv.length + new Uint8Array(enc).length);
      combined.set(iv);
      combined.set(new Uint8Array(enc), iv.length);
      setOutput(bytesToHex(combined.buffer));
      return;
    }

    if (alg === 'bcrypt' || alg === 'scrypt' || alg === 'Argon2id') {
      var hashWasm = (typeof hashwasm !== 'undefined' ? hashwasm : null) || (typeof window !== 'undefined' && window.hashwasm) || null;
      if (!hashWasm) {
        showErr(alg + ' requires the hash-wasm library. Load the page from http(s) and ensure scripts from cdn.jsdelivr.net are not blocked.');
        return;
      }
      try {
        if (alg === 'bcrypt') {
          var saltBcrypt = crypto.getRandomValues(new Uint8Array(16));
          var bcryptHash = await hashWasm.bcrypt({
            password: raw,
            salt: saltBcrypt,
            costFactor: 10,
            outputType: 'encoded'
          });
          setOutput(bcryptHash);
        } else if (alg === 'scrypt') {
          var saltScrypt = crypto.getRandomValues(new Uint8Array(16));
          var scryptHash = await hashWasm.scrypt({
            password: raw,
            salt: saltScrypt,
            costFactor: 16384,
            blockSize: 8,
            parallelism: 1,
            hashLength: 64,
            outputType: 'hex'
          });
          setOutput(bytesToHex(saltScrypt.buffer) + ':' + scryptHash);
        } else {
          var saltArgon = crypto.getRandomValues(new Uint8Array(16));
          var argonHash = await hashWasm.argon2id({
            password: raw,
            salt: saltArgon,
            iterations: 256,
            parallelism: 1,
            memorySize: 512,
            hashLength: 32,
            outputType: 'encoded'
          });
          setOutput(argonHash);
        }
      } catch (e) {
        showErr(alg + ' failed: ' + (e.message || String(e)));
      }
    }
  }

  async function doDecode() {
    var alg = algo.value;
    var raw = (input.value || '').trim();
    showErr('');
    setOutput('');
    if (!isReversibleAlgo()) {
      showErr('Only reversible algorithms (AES-128-GCM, AES-256-GCM) can be decoded.');
      return;
    }
    if (!raw) { showErr('Paste hex ciphertext to decrypt.'); return; }
    var keyStr = getKeyRaw();
    if (!keyStr) { showErr('Select or enter the key that was used to encrypt.'); return; }
    try {
      var combinedBuf = hexToBytes(raw);
      var u8 = new Uint8Array(combinedBuf);
      if (u8.length < 12 + 16) { showErr('Ciphertext too short (expected IV + tag + data).'); return; }
      var ivDec = u8.slice(0, 12);
      var cipher = u8.slice(12).buffer;
      var keyHashFull = new Uint8Array(await crypto.subtle.digest('SHA-256', strToBytes(keyStr)));
      var keyLen = alg === 'AES-128-GCM' ? 128 : 256;
      var keyBytesDec = keyLen === 128 ? keyHashFull.slice(0, 16) : keyHashFull;
      var keyBufDec = keyLen === 128 ? keyBytesDec.buffer.slice(0, 16) : keyBytesDec.buffer;
      var keyDec = await crypto.subtle.importKey('raw', keyBufDec, { name: 'AES-GCM', length: keyLen }, false, ['decrypt']);
      var dec = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: ivDec, tagLength: 128 }, keyDec, cipher);
      setOutput(new TextDecoder().decode(dec));
    } catch (e) {
      showErr('Decrypt failed: wrong key or invalid ciphertext.');
    }
  }

  btnDetect.addEventListener('click', detectHash);
  btnEncode.addEventListener('click', doEncode);
  btnDecode.addEventListener('click', doDecode);

  algo.addEventListener('change', updateUI);
  updateUI();

  showKey.addEventListener('change', function() {
    keyInput.type = showKey.checked ? 'text' : 'password';
  });

  btnLoadKey.addEventListener('click', function() {
    var name = (keySelect.value || '').trim();
    if (!name) { keyInput.value = ''; return; }
    var obj = getStoredKeys();
    var val = keyEntryValue(obj[name]);
    keyInput.value = val != null ? val : '';
  });

  btnSaveKey.addEventListener('click', function() {
    var name = (saveKeyName.value || '').trim().toLowerCase().replace(/\s+/g, '-');
    var val = (keyInput.value || '').trim();
    if (!name) { showErr('Enter a name to save the key.'); return; }
    if (!val) { showErr('Enter a key to save.'); return; }
    if (!setStoredKeyByName(name, val)) { showErr('A key with this name already exists. Use a different name or delete it in the Keys manager.'); return; }
    refreshKeyDropdown();
    keySelect.value = name;
    showErr('');
  });

  window.addEventListener('storage', refreshKeyDropdown);
  refreshKeyDropdown();
})();
  </script>
</body>
</html>
